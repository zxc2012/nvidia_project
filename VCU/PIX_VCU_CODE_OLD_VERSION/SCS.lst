C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 1   


C166 COMPILER V7.00, COMPILATION OF MODULE SCS
OBJECT MODULE PLACED IN SCS.obj
COMPILER INVOKED BY: H:\KEILC166\C166\BIN\C166.EXE source\SCS.c MODV2 BROWSE INCDIR(.\source;.\lib) MODV2 DEBUG PRINT(.\
                    -SCS.lst) OBJECT(SCS.obj) 

 stmt lvl     source

    1         //****************************************************************************
    2         // @Module        Project Settings
    3         // @Filename      SCS.c
    4         // @Project       tiaoshi.dav
    5         //----------------------------------------------------------------------------
    6         // @Controller    Infineon XC2267M-104F80
    7         //
    8         // @Compiler      Keil
    9         //
   10         // @Codegenerator 2.0
   11         //
   12         // @Description   This file contains the SCS driver.
   13         //                      
   14         //                Note:
   15         //                This file should not be changed by 
   16         //                the user.
   17         //
   18         //----------------------------------------------------------------------------
   19         // @Date          2020/1/14 16:27:45
   20         //
   21         //****************************************************************************
   22         
   23         // USER CODE BEGIN (SCS_General,1)
   24         
   25         // USER CODE END
   26         
   27         
   28         
   29         //****************************************************************************
   30         // @Project Includes
   31         //****************************************************************************
   32         
   33         #include "MAIN.h"
   34         
   35         // USER CODE BEGIN (SCS_General,2)
   36         
   37         // USER CODE END
   38         
   39         
   40         //****************************************************************************
   41         // @Macros
   42         //****************************************************************************
   43         
   44         
   45         //****************************************************************************
   46         // @Defines
   47         //****************************************************************************
   48         
   49         // USER CODE BEGIN (SCS_General,3)
   50         
   51         // USER CODE END
   52         
   53         
   54         // Function-like macros ******************************************************
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 2   

   55         
   56         // PLLSTAT_COND_3: For polling a PLLSTAT condition up to 3 times; an "if"
   57         // construct needs at least 12 instruction cycles before 3rd check. "
   58         // Depending on the compiler (optimization) and the program location, the
   59         // effective number of instruction cycles may be higher.
   60         #define PLLSTAT_COND_3(Condition) (((Condition) && (Condition)) && (Condition))
   61         
   62         // GET_CYCLES: Converts Time[us] and MaxSysFreq[Hz] into cycles for timer,
   63         // rounding up; for compile-time use only.
   64         #define GET_CYCLES(Time, MaxSysFreq) \
   65                 ((unsigned int)(((((long)(Time))*((MaxSysFreq)/1000))+15999)/16000))
   66         
   67         // Constants that may be overwritten by the user *****************************
   68         
   69         // If not user defined:
   70         // Number of attempts for high precision osc. start
   71         #ifndef SCS_ATTEMPTS_OSC_HP
   72         #define SCS_ATTEMPTS_OSC_HP 10
   73         #endif
   74         
   75         // If not user defined:
   76         // Timeout in [us] for PLLV after high precision osc. start
   77         #ifndef SCS_TIME_OSC_HP_PLLV
   78         #define SCS_TIME_OSC_HP_PLLV 5000
   79         #endif
   80         
   81         // If not user defined:
   82         // Delay time/timeout in [us] for 1024 cycles after high precision osc. start
   83         #ifndef SCS_TIME_OSC_HP_1024
   84         #define SCS_TIME_OSC_HP_1024 1000
   85         #endif
   86         
   87         // Constants that cannot be overwritten by the user **************************
   88         
   89         // Maximum system frequency values in [Hz]
   90         #define SCS_F_INT_5MHZ 5200000
   91         #define SCS_F_INT_10MHZ 10400000
   92         
   93         // Other times in [us]
   94         #define SCS_TIME_VCO_BAND_SWITCH 150
   95         #define SCS_TIME_VCO_FINDIS_TO_BASE 50
   96         #define SCS_TIME_VCO_K2 5
   97         #define SCS_TIME_VCO_LOCK 200
   98         
   99         // Check clock parameters ****************************************************
  100         
  101         // Check fXTAL
  102         #if SCS_F_XTAL < 4000000 || SCS_F_XTAL > 25000000
              #   error  "SCS_F_XTAL out of range"
              #endif
  105         
  106         // Check fPLL target frequency
  107         #if SCS_F_PLL_TARGET < 1000000 || SCS_F_PLL_TARGET > 80000000
              #   error  "SCS_F_PLL_TARGET out of range"
              #endif
  110         
  111         // check fP
  112         #if SCS_F_P < 4000000 || SCS_F_P > 16000000
              #   error  "SCS_F_P out of range"
              #endif
  115         
  116         // check fVCO
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 3   

  117         #if SCS_F_VCO < 10000000 || SCS_F_VCO > 160000000
              #   error  "SCS_F_VCO out of range"
              #endif
  120         
  121         // Check P divider
  122         #if SCS_P < 1 || SCS_P > 16
              #   error  "SCS_P out of range"
              #endif
  125         
  126         // Check N divider
  127         #if SCS_N < 16 || SCS_N > 40
              #   error  "SCS_N out of range"
              #endif
  130         
  131         // Check K2_5MHZ divider
  132         #if SCS_K2_5MHZ < 1 || SCS_K2_5MHZ > 512
              #   error  "SCS_K2_5MHZ out of range"
              #endif
  135         
  136         // Check K2 divider and additional K2 divider steps if defined
  137         
  138         #if SCS_K2 < 1 || SCS_K2 > 512
              #   error  "SCS_K2 out of range"
              #endif
  141         
  142         #ifdef SCS_K2_1
  143         #  if SCS_K2_1 < 1 || SCS_K2_1 > 512
              #     error  "SCS_K2_1 out of range"
              #  endif
  146         #endif
  147         
  148         #ifdef SCS_K2_2
  149         #  if SCS_K2_2 < 1 || SCS_K2_2 > 512
              #     error  "SCS_K2_2 out of range"
              #  endif
  152         #endif
  153         
  154         #ifdef SCS_K2_3
  155         #  if SCS_K2_3 < 1 || SCS_K2_3 > 512
              #     error  "SCS_K2_3 out of range"
              #  endif
  158         #endif
  159         
  160         #ifdef SCS_K2_4
              #  if SCS_K2_4 < 1 || SCS_K2_4 > 512
              #     error  "SCS_K2_4 out of range"
              #  endif
              #endif
  165         
  166         
  167         
  168         //****************************************************************************
  169         // @Typedefs
  170         //****************************************************************************
  171         
  172         
  173         
  174         //****************************************************************************
  175         // @Imported Global Variables
  176         //****************************************************************************
  177         
  178         
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 4   

  179         
  180         //****************************************************************************
  181         // @Global Variables
  182         //****************************************************************************
  183         
  184         
  185         
  186         //****************************************************************************
  187         // @Privare Variables
  188         //****************************************************************************
  189         
  190         // Saved value of CCU60_KSCFG
  191         static unsigned int Ccu60KscfgSave;
  192         
  193         // Saved value of CCU60 MCFG
  194         static unsigned int Ccu60McfgSave;
  195         
  196         // Saved value of CCU60 TCTR0
  197         static unsigned int Ccu60Tctr0Save;
  198         
  199         // Saved value of CCU60 TCTR2
  200         static unsigned int Ccu60Tctr2Save;
  201         
  202         // Saved value of CCU60 PISELH
  203         static unsigned int Ccu60PiselhSave;
  204         
  205         
  206         
  207         //****************************************************************************
  208         // @External Prototypes
  209         //****************************************************************************
  210         
  211         
  212         
  213         //****************************************************************************
  214         // @Prototypes Of Local Functions
  215         //****************************************************************************
  216         
  217         static SCS_ErrorType SCS_RampUpPllInNormalMode(void);
  218         
  219         
  220         //****************************************************************************
  221         // @Local Functions
  222         //****************************************************************************
  223         
  224         //****************************************************************************;
  225         // @Function      inline void SCS_EnableOscHiPrecCrystal(void)
  226         //
  227         //-----------------------------------------------------------------------------
  228         // @Description   This expert level function configures the high precision
  229         //                oscillator for crystal mode.
  230         //                
  231         //                Notes:
  232         //                - The user is responsible for disabling the register
  233         //                  protection.
  234         //
  235         //-----------------------------------------------------------------------------
  236         // @Returnvalue   None
  237         //
  238         //-----------------------------------------------------------------------------
  239         // @Parameters    None
  240         //
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 5   

  241         //-----------------------------------------------------------------------------
  242         // @Date          2020/1/14
  243         //
  244         //-----------------------------------------------------------------------------
  245         
  246         // USER CODE BEGIN (SCS_EnableOscHiPrecCrystal,1)
  247         
  248         // USER CODE END
  249         
  250         _inline void SCS_EnableOscHiPrecCrystal(void)
  251         {
  252  1         // clear MODE for external crystal/clock, clear SHBY to disable shaper bypass,
  253  1         // clear rh and w bits, leave other bits unchanged
  254  1         SCU_HPOSCCON &=
  255  1          ((0U    <<0U) | // PLLV for PLL Valid Status Bit (rh)
  256  1                          // 0: OSC_HP frequency is not usable
  257  1                          // 1: OSC_HP frequency is usable
  258  1           (0U    <<1U) | // OSCWDTRST Oscillator Watchdog Reset
  259  1                          // 0 : Osc. watchdog is not reset and remains active
  260  1                          // 1 : Osc. watchdog is reset and restarted
  261  1           (0U    <<2U) | // MODE Oscillator Mode
  262  1                          // 0 : External crystal/clock, no osc. power-saving mode
  263  1                          // 1 : OSC_HP disabled, no osc. power-saving mode
  264  1                          // 2 : External clock, osc. power-saving mode
  265  1                          // 3 : OSC_HP disabled, osc. power-saving mode
  266  1           (0U    <<4U) | // GAINSEL Oscillator Gain Selection (rh)
  267  1                          // 0: gain control from 4 MHz to 8 MHz
  268  1                          // 1: gain control from 4 MHz to 16 MHz
  269  1                          // 2: gain control from 4 MHz to 20 MHz
  270  1                          // 3: gain control from 4 MHz to 25 MHz
  271  1           (0U    <<6U) | // X1D XTAL1 Data Value (rh)
  272  1                          // inverted level of pin XTAL1 if X1DEN is set
  273  1           (1U    <<7U) | // X1DEN XTAL1 Data Enable
  274  1                          // 0 : 0 Bit X1D is not updated
  275  1                          // 1 : 1 Bit X1D can be updated
  276  1           (0U    <<8U) | // SHBY Shaper Bypass
  277  1                          // 0 : 0 Shaper is not bypassed
  278  1                          // 1 : 1 Shaper is bypassed
  279  1           (1U    <<9U) | // EMCLKEN OSCWDT Emergency System Clock Source Select Enable
  280  1                          // 0 : MCM controlled by SYSCON0.CLKSEL in OSCWDT emergency case
  281  1                          // 1 : MCM controlled by SYSCON0.EMCLKSEL in OSCWDT emergency case
  282  1           (1U    <<10U)| // EMFINDISEN Emergency Input Clock Disconnect Enable
  283  1                          // 0 : PLLSTAT.FINDIS not updated in OSCWDT emergency case
  284  1                          // 1 : PLLSTAT.FINDIS is set in OSCWDT emergency case
  285  1           (0U    <<11U)| // OSC2L1 OSCWDT Reached Status (rh)
  286  1                          // 0: OSCWDT did not detect frequency below limit
  287  1                          // 1: OSCWDT detected frequency below limit
  288  1           (0U    <<12U));// OSC2L0 OSCWDT Left Status (rh)
  289  1                          // 0: OSCWDT did not detect frequency above limit
  290  1                          // 1: OSCWDT detected frequency above limit
  291  1      
  292  1      } // end of function SCS_EnableOscHiPrecCrystal
  293         
  294         //****************************************************************************;
  295         // @Function      inline void SCS_RestartVcoLockDetect(void)
  296         //
  297         //-----------------------------------------------------------------------------
  298         // @Description   This expert level function restarts the VCO lock detection.
  299         //                
  300         //                Notes:
  301         //                - The user is responsible for disabling the register
  302         //                  protection.
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 6   

  303         //
  304         //-----------------------------------------------------------------------------
  305         // @Returnvalue   None
  306         //
  307         //-----------------------------------------------------------------------------
  308         // @Parameters    None
  309         //
  310         //-----------------------------------------------------------------------------
  311         // @Date          2020/1/14
  312         //
  313         //-----------------------------------------------------------------------------
  314         
  315         // USER CODE BEGIN (SCS_RestartVcoLockDetect,1)
  316         
  317         // USER CODE END
  318         
  319         _inline void SCS_RestartVcoLockDetect(void)
  320         {
  321  1         // restart VCO lock detection
  322  1         SCU_PLLCON1_RESLD =
  323  1          1U;             // RESLD: Restart VCO Lock Detection (w)
  324  1                          // Setting this bit will reset bit PLLSTAT.VCOLOCK and
  325  1                          // restart the VCO lock detection
  326  1      
  327  1      } // end of function SCS_RestartVcoLockDetect
  328         
  329         //****************************************************************************;
  330         // @Function      inline void SCS_DisconnectVcoInput(void)
  331         //
  332         //-----------------------------------------------------------------------------
  333         // @Description   This expert level function disconnects VCO from its clock
  334         //                input.
  335         //                
  336         //                Notes:
  337         //                - The user is responsible for disabling the register
  338         //                  protection.
  339         //
  340         //-----------------------------------------------------------------------------
  341         // @Returnvalue   None
  342         //
  343         //-----------------------------------------------------------------------------
  344         // @Parameters    None
  345         //
  346         //-----------------------------------------------------------------------------
  347         // @Date          2020/1/14
  348         //
  349         //-----------------------------------------------------------------------------
  350         
  351         // USER CODE BEGIN (SCS_DisconnectVcoInput,1)
  352         
  353         // USER CODE END
  354         
  355         _inline void SCS_DisconnectVcoInput(void)
  356         {
  357  1         // disconnect VCO from its clock input
  358  1         SCU_STATCLR1 =
  359  1           (0U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
  360  1           (0U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
  361  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
  362  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L2 (w)
  363  1           (1U    <<4U) | // Set PLLSTAT.FINDIS (w)
  364  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 7   

  365  1      
  366  1      } // end of function SCS_DisconnectVcoInput
  367         
  368         //****************************************************************************;
  369         // @Function      inline void SCS_ConnectVcoInput(void)
  370         //
  371         //-----------------------------------------------------------------------------
  372         // @Description   This expert level function connects VCO from its clock
  373         //                input.
  374         //                
  375         //                Notes:
  376         //                - The user is responsible for disabling the register
  377         //                  protection.
  378         //
  379         //-----------------------------------------------------------------------------
  380         // @Returnvalue   None
  381         //
  382         //-----------------------------------------------------------------------------
  383         // @Parameters    None
  384         //
  385         //-----------------------------------------------------------------------------
  386         // @Date          2020/1/14
  387         //
  388         //-----------------------------------------------------------------------------
  389         
  390         // USER CODE BEGIN (SCS_ConnectVcoInput,1)
  391         
  392         // USER CODE END
  393         
  394         _inline void SCS_ConnectVcoInput(void)
  395         {
  396  1         // connect VCO from its clock input
  397  1         SCU_STATCLR1 =
  398  1           (0U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
  399  1           (0U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
  400  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
  401  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L2 (w)
  402  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
  403  1           (1U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
  404  1      
  405  1      } // end of function SCS_ConnectVcoInput
  406         
  407         //****************************************************************************;
  408         // @Function      inline void SCS_SelectVcoBand(unsigned int VcoBand)
  409         //
  410         //-----------------------------------------------------------------------------
  411         // @Description   This expert level function sets the required VCO band.
  412         //                
  413         //                Notes:
  414         //                - The user is responsible for disabling the register
  415         //                  protection.
  416         //
  417         //-----------------------------------------------------------------------------
  418         // @Returnvalue   None
  419         //
  420         //-----------------------------------------------------------------------------
  421         // @Parameters    VcoBand: 0 or 1
  422         //
  423         //-----------------------------------------------------------------------------
  424         // @Date          2020/1/14
  425         //
  426         //-----------------------------------------------------------------------------
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 8   

  427         
  428         // USER CODE BEGIN (SCS_SelectVcoBand,1)
  429         
  430         // USER CODE END
  431         
  432         _inline void SCS_SelectVcoBand(unsigned int VcoBand)
  433         {
  434  1         // select VCO band
  435  1         SCU_PLLCON0_VCOSEL = VcoBand;
  436  1      
  437  1      } // end of function SCS_SelectVcoBand
  438         
  439         //****************************************************************************;
  440         // @Function      inline void SCS_StartTimer(unsigned int Cycles)
  441         //
  442         //-----------------------------------------------------------------------------
  443         // @Description   This expert level function starts timer T13 for counting
  444         //                a certain number of clocks.
  445         //                
  446         //                Notes:
  447         //                - It is assumed that the timer is already initialized by 
  448         //                  SCS_InitTimer.
  449         //                - Cycles < 3 are set to 3 for hardware reasons.
  450         //
  451         //-----------------------------------------------------------------------------
  452         // @Returnvalue   None
  453         //
  454         //-----------------------------------------------------------------------------
  455         // @Parameters    Cycles: Number of T13 clocks to count, 0...65535
  456         //
  457         //-----------------------------------------------------------------------------
  458         // @Date          2020/1/14
  459         //
  460         //-----------------------------------------------------------------------------
  461         
  462         // USER CODE BEGIN (SCS_StartTimer,1)
  463         
  464         // USER CODE END
  465         
  466         _inline void SCS_StartTimer(unsigned int Cycles)
  467         {
  468  1         // stop T13 for security reasons, clear T13
  469  1         CCU60_TCTR4 =
  470  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  471  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  472  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  473  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w))
  474  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  475  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  476  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  477  1           (1U    <<8U) | // T13RR Timer 13 Run Reset (w)
  478  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
  479  1           (1U    <<10U)| // T13RES Timer 13 Reset (w)
  480  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  481  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  482  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  483  1      
  484  1         // limit T13 period
  485  1         if (Cycles < 3U)
  486  1         {
  487  2           Cycles = 3U;
  488  2         }
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 9   

  489  1      
  490  1         //set T13 period
  491  1         CCU60_T13PR = Cycles - 2U;
  492  1      
  493  1         // enable T13 shadow transfer for period setting
  494  1         CCU60_TCTR4 =
  495  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  496  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  497  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  498  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w))
  499  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  500  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  501  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  502  1           (0U    <<8U) | // T13RR Timer 13 Run Reset (w)
  503  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
  504  1           (0U    <<10U)| // T13RES Timer 13 Reset (w)
  505  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  506  1           (1U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  507  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  508  1      
  509  1         // start T13
  510  1         CCU60_TCTR4 =
  511  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  512  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  513  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  514  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w))
  515  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  516  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  517  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  518  1           (0U    <<8U) | // T13RR Timer 13 Run Reset (w)
  519  1           (1U    <<9U) | // T13RS Timer 13 Run Set (w)
  520  1           (0U    <<10U)| // T13RES Timer 13 Reset (w)
  521  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  522  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  523  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  524  1      
  525  1      } // end of function SCS_StartTimer
  526         
  527         //****************************************************************************;
  528         // @Function      inline void SCS_DelayByTimer(unsigned int Cycles)
  529         //
  530         //-----------------------------------------------------------------------------
  531         // @Description   This expert level function starts timer T13 and waits until
  532         //                the specified number of clocks is counted.
  533         //                
  534         //                Notes:
  535         //                - It is assumed that the timer is already initialized by 
  536         //                  SCS_InitTimer.
  537         //                - Cycles < 3 are set to 3 for hardware reasons.
  538         //
  539         //-----------------------------------------------------------------------------
  540         // @Returnvalue   None
  541         //
  542         //-----------------------------------------------------------------------------
  543         // @Parameters    Cycles: Number of T13 clocks to count, 0...65535
  544         //
  545         //-----------------------------------------------------------------------------
  546         // @Date          2020/1/14
  547         //
  548         //-----------------------------------------------------------------------------
  549         
  550         // USER CODE BEGIN (SCS_DelayByTimer,1)
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 10  

  551         
  552         // USER CODE END
  553         
  554         _inline void SCS_DelayByTimer(unsigned int Cycles)
  555         {
  556  1         // start delay timer T13
  557  1         SCS_StartTimer(Cycles);
  558  1      
  559  1         // wait until delay time clocks are counted
  560  1         do
  561  1         {
  562  2         }
  563  1         while(CCU60_TCTR0_T13R);
  564  1      
  565  1      } // end of function SCS_DelayByTimer
  566         
  567         
  568         //****************************************************************************;
  569         // @Function      SCS_ErrorType SCS_RampUpPllInNormalMode (void)
  570         //
  571         //-----------------------------------------------------------------------------
  572         // @Description   This private function performs a ramp-up of the PLL in 
  573         //                Normal Operation Mode.
  574         //
  575         //                Notes: 
  576         //                - The user is responsible for disabling the register
  577         //                  protection.
  578         //-----------------------------------------------------------------------------
  579         // @Returnvalue   Error code
  580         //
  581         //-----------------------------------------------------------------------------
  582         // @Parameters    None
  583         //
  584         //-----------------------------------------------------------------------------
  585         // @Date          2020/1/14
  586         //
  587         //-----------------------------------------------------------------------------
  588         
  589         // USER CODE BEGIN (SCS_RampUpPllInNormalMode,1)
  590         
  591         // USER CODE END
  592         
  593         
  594         static SCS_ErrorType SCS_RampUpPllInNormalMode(void)
  595         {
  596  1         SCS_ErrorType Error;
  597  1      
  598  1         #ifdef SCS_K2_1
  599  1           // set additional K2 divider step SCS_K2_1 if needed
  600  1           Error = SCS_ApplyNewK2Div(((unsigned int)SCS_K2_1) - 1U);
  601  1           if(Error)
  602  1           {
  603  2             return Error;
  604  2           }
  605  1      
  606  1           #ifdef SCS_K2_2
  607  1             // wait delay time for K2 with new system clock
  608  1             SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_1));
  609  1      
  610  1             // set additional K2 divider step SCS_K2_2 if needed
  611  1             Error = SCS_ApplyNewK2Div(((unsigned int)SCS_K2_2) - 1U);
  612  1             if(Error)
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 11  

  613  1             {
  614  2               return Error;
  615  2             }
  616  1      
  617  1             #ifdef SCS_K2_3
  618  1               // wait delay time for K2 switch with new system clock
  619  1               SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_2));
  620  1      
  621  1               // set additional K2 divider step SCS_K2_3 if needed
  622  1               Error = SCS_ApplyNewK2Div((((unsigned int)SCS_K2_3)) - 1U);
  623  1               if(Error)
  624  1               {
  625  2                 return Error;
  626  2               }
  627  1               // wait delay time for K2_3 with new system clock
  628  1               SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_3));
  629  1             #else
                       // no SCS_K2_3: wait delay time for K2_2 with new system clock
                       SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_2));
                     #endif  // SCS_K2_3
  633  1      
  634  1           #else
                     // no SCS_K2_2: wait delay time for K2_1 with new system clock
                     SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_1));
                   #endif  // SCS_K2_2
  638  1      
  639  1         #endif  // SCS_K2_1
  640  1      
  641  1         // set final K2 divider SCS_K2
  642  1         Error = SCS_ApplyNewK2Div((((unsigned int)SCS_K2)) - 1U);
  643  1         if(Error)
  644  1         {
  645  2           return Error;
  646  2         }
  647  1      
  648  1         // no error
  649  1         return SCS_STATE_NO_ERROR;
  650  1      
  651  1      }  // end of function SCS_RampUpPllInNormalMode
  652         
  653         
  654         //****************************************************************************;
  655         // @Function      SCS_ErrorType SCS_GoFromBaseToNormalMode (void)
  656         //
  657         //-----------------------------------------------------------------------------
  658         // @Description   This use case function performs a transition from Base Mode 
  659         //                to Normal Operation Mode.
  660         //
  661         //                Notes: 
  662         //                - The user is responsible for disabling the register
  663         //                  protection.
  664         //-----------------------------------------------------------------------------
  665         // @Returnvalue   Error code
  666         //
  667         //-----------------------------------------------------------------------------
  668         // @Parameters    None
  669         //
  670         //-----------------------------------------------------------------------------
  671         // @Date          2020/1/14
  672         //
  673         //-----------------------------------------------------------------------------
  674         
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 12  

  675         // USER CODE BEGIN (SCS_GoFromBaseToNormalMode,1)
  676         
  677         // USER CODE END
  678         
  679         
  680         SCS_ErrorType SCS_GoFromBaseToNormalMode(void)
  681         {
  682  1         SCS_ErrorType Error;
  683  1      
  684  1         // enable high precision oscillator for crystal
  685  1         SCS_EnableOscHiPrecCrystal();
  686  1      
  687  1         // check high precision oscillator frequency
  688  1         Error = SCS_CheckFreqOscHiPrec();
  689  1         if(Error)
  690  1         {
  691  2           return Error;
  692  2         }
  693  1      
  694  1         // set K1 divider = 1 for VCO bypass frequency of 5 MHz
  695  1         Error = SCS_ApplyNewK1Div(1U - 1U);
  696  1         if(Error)
  697  1         {
  698  2           return Error;
  699  2         }
  700  1      
  701  1         // enable VCO bypass, new fSYS = 5 MHz
  702  1         Error = SCS_EnableVcoBypass();
  703  1         if(Error)
  704  1         {
  705  2           return Error;
  706  2         }
  707  1      
  708  1         if(!SCU_PLLCON0_VCOSEL)
  709  1         {  // current VCO band = 0:
  710  2      
  711  2            // select VCO band 1
  712  2            SCS_SelectVcoBand(1U);
  713  2      
  714  2            // wait band switch delay time with 5 MHz int. osc.
  715  2            SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_BAND_SWITCH, SCS_F_INT_5MHZ));
  716  2         }
  717  1         else
  718  1         {  // current VCO band = 1:
  719  2      
  720  2            // set K2 divider = 8
  721  2            Error = SCS_ApplyNewK2Div(8U - 1U);
  722  2            if(Error)
  723  2            {
  724  3              return Error;
  725  3            }
  726  2         }
  727  1      
  728  1         // set final P divider
  729  1         Error = SCS_ApplyNewPDiv((((unsigned int)SCS_P)) - 1U);
  730  1         if(Error)
  731  1         {
  732  2           return Error;
  733  2         }
  734  1      
  735  1         // set final N divider
  736  1         Error = SCS_ApplyNewNDiv((((unsigned int)SCS_N)) - 1U);
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 13  

  737  1         if(Error)
  738  1         {
  739  2           return Error;
  740  2         }
  741  1      
  742  1         // disconnect VCO from clock input (enable free-running oscillator)
  743  1         SCS_DisconnectVcoInput();
  744  1      
  745  1         // wait until base frequency is reached with 10 MHz int. osc.
  746  1         SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_FINDIS_TO_BASE, SCS_F_INT_10MHZ));
  747  1      
  748  1         // disable VCO bypass, new fSYS ~ (50 MHz / 8) ~ 6.3 MHz
  749  1         Error = SCS_DisableVcoBypass();
  750  1         if(Error)
  751  1         {
  752  2           return Error;
  753  2         }
  754  1      
  755  1         // select high precision oscillator as VCO source
  756  1         Error = SCS_SelectVcoSrcOscHiPrec();
  757  1         if(Error)
  758  1         {
  759  2           return Error;
  760  2         }
  761  1      
  762  1         // set K2 for fSYS = 5 MHz with final settings, new fSYS ~ (50 MHz / K2)
  763  1         // for fVCO = 160 MHz: K2 = 32, new fSYS ~ 1.6 MHz
  764  1         Error = SCS_ApplyNewK2Div(((unsigned int)SCS_K2_5MHZ) - 1U);
  765  1         if(Error)
  766  1         {
  767  2           return Error;
  768  2         }
  769  1      
  770  1         // connect VCO to clock input, new fSYS ~ 5MHz
  771  1         SCS_ConnectVcoInput();
  772  1      
  773  1         // restart VCO lock detection
  774  1         SCS_RestartVcoLockDetect();
  775  1      
  776  1         // start timer for VCO lock with maximum ~ 5 MHz
  777  1         SCS_StartTimer(GET_CYCLES(SCS_TIME_VCO_LOCK, SCS_F_INT_5MHZ));
  778  1      
  779  1         // wait until lock occurs or timeout is over
  780  1         do
  781  1         {
  782  2         }
  783  1         while((!SCU_PLLSTAT_VCOLOCK) && CCU60_TCTR0_T13R);
  784  1         if(!SCU_PLLSTAT_VCOLOCK)
  785  1         {
  786  2           // no VCO lock
  787  2           return SCS_STATE_TO_VCO_LOCK;
  788  2         }
  789  1      
  790  1         // enable VCOLCK emergency
  791  1         Error = SCS_EnableVcoLockEmerg();
  792  1         if(Error)
  793  1         {
  794  2           return Error;
  795  2         }
  796  1      
  797  1         // ramp up PLL for fSys = final value in normal operation mode
  798  1         Error = SCS_RampUpPllInNormalMode();
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 14  

  799  1         if(Error)
  800  1         {
  801  2           return Error;
  802  2         }
  803  1      
  804  1         // no error
  805  1         return SCS_STATE_NO_ERROR;
  806  1      
  807  1      }  // end of function SCS_GoFromBaseToNormalMode
  808         
  809         
  810         //****************************************************************************;
  811         // @Function      void SCS_InitTimer (void)
  812         //-----------------------------------------------------------------------------
  813         // @Description   This function configures CCU6 timer T13 as one-shot timer with
  814         //                a resolution of 16 CCU6 clocks = 16 system clocks.
  815         //
  816         //                Notes:
  817         //                - The function will enable CCU6 and will overwrite previous
  818         //                  settings for T13.
  819         //                - The function will save the previous CCU6 register contents;
  820         //                  they may be restored via SCS_RestoreTimer.
  821         //                - The user must call this function before any other SCS driver
  822         //                  function. (except SCS_SelectBandgapHiPrec if needed).
  823         //                - The user is responsible for disabling the register protection.
  824         //
  825         //-----------------------------------------------------------------------------
  826         // @Returnvalue   None
  827         //
  828         //-----------------------------------------------------------------------------
  829         // @Parameters    None
  830         //
  831         //-----------------------------------------------------------------------------
  832         // @Date          2020/1/14
  833         //
  834         //-----------------------------------------------------------------------------
  835         
  836         // USER CODE BEGIN (SCS_InitTimer,1)
  837         
  838         // USER CODE END
  839         
  840         void SCS_InitTimer(void)
  841         {
  842  1         volatile unsigned int Work;
  843  1      
  844  1         // save CCU60_KSCFG
  845  1         Ccu60KscfgSave = CCU60_KSCFG;
  846  1      
  847  1         // enable CC60 module
  848  1         CCU60_KSCFG |=
  849  1           (1U    <<0U) | // MODEN Module Enable
  850  1           (1U    <<1U) | // BPMODEN Bit Protection for MODEN, set to 1 for change (w)
  851  1           (0U    <<4U) | // NOMCFG Normal Operation Mode Configuration
  852  1                          // kernel mode applied in normal operation mode
  853  1           (0U    <<7U) | // BPNOM Bit Protection for NOMCFG, set to 1 for change (w)
  854  1           (0U    <<8U) | // SUMCFG Suspend Mode Configuration
  855  1                          // Kernel mode applied in suspend mode
  856  1           (0U    <<11U)| // BPSUM Bit Protection for SUMCFG, set to 1 for change (w)
  857  1           (0U    <<12U)| // COMCFG Clock Off Mode Configuration
  858  1                          // kernel mode applied in clock off mode
  859  1           (0U    <<15U); // BPCOM Bit Protection for COMCFG, set to 1 for change (w)
  860  1      
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 15  

  861  1         // read SFR back to avoid pipeline effects
  862  1         Work = CCU60_KSCFG;
  863  1      
  864  1         // save CCU60_MCFG
  865  1         Ccu60McfgSave = CCU60_MCFG;
  866  1      
  867  1         // enable T13 functionality, leave other bits unchanged
  868  1         CCU60_MCFG |=
  869  1           (0U    <<0U) | // T12 T12 Available
  870  1           (1U    <<1U) | // T13 T13 Available
  871  1           (0U    <<2U);  // MCM Multi-Channel Mode Available
  872  1       
  873  1         // stop T13, clear T13
  874  1         // (CCU60_TCTR4 needs not be saved)
  875  1         CCU60_TCTR4 =
  876  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  877  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  878  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  879  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w)
  880  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  881  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  882  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  883  1           (1U    <<8U) | // T13RR Timer 13 Run Reset (w)
  884  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
  885  1           (1U    <<10U)| // T13RES Timer 13 Reset (w)
  886  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  887  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  888  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  889  1      
  890  1         // save CCU60_TCTR0
  891  1         Ccu60Tctr0Save = CCU60_TCTR0;
  892  1       
  893  1         // set T13 period, for fCC6/16, clear T13PRE to disable additional prescaler,
  894  1         // leave bits T12CLK, T12PRE, CTM unchanged
  895  1         CCU60_TCTR0 = (CCU60_TCTR0 & ((7U <<0U)|(1U <<3U)|(1U <<7U))) |
  896  1           ((0U    <<0U) | // T12CLK Timer T12 Input Clock Select
  897  1                          // 0: f = fCC6
  898  1                          // 1: f = fCC6 / 2
  899  1                          // 2: f = fCC6 / 4
  900  1                          // 3: f = fCC6 / 8
  901  1                          // 4: f = fCC6 / 16
  902  1                          // 5: f = fCC6 / 32
  903  1                          // 6: f = fCC6 / 64
  904  1                          // 7: f = fCC6 / 128
  905  1           (0U    <<3U) | // T12PRE Timer T12 Prescaler Bit
  906  1                          // 0: additional prescaler disabled
  907  1                          // 1: additional prescaler enabled
  908  1           (0U    <<4U) | // T12R Timer T12 Run Bit (rh)
  909  1                          // 0: Timer is stopped
  910  1                          // 1: Timer is running
  911  1           (0U    <<5U) | // STE12 Timer T12 Shadow Transfer Enable (rh)
  912  1                          // 0: Shadow register transfer is disabled
  913  1                          // 1: Shadow register transfer is enabled
  914  1           (0U    <<6U) | // CDIR Count Direction of Timer T12 (rh)
  915  1                          // 0: T12 counts up
  916  1                          // 1: T12 counts down
  917  1           (0U    <<7U) | // CTM T12 Operating Mode
  918  1                          // 0: Edge-aligned Mode
  919  1                          // 1: Center-aligned Mode
  920  1           (4U    <<8U) | // T13CLK Timer T13 Input Clock Select
  921  1                          // 0: f = fCC6
  922  1                          // 1: f = fCC6 / 2
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 16  

  923  1                          // 2: f = fCC6 / 4
  924  1                          // 3: f = fCC6 / 8
  925  1                          // 4: f = fCC6 / 16
  926  1                          // 5: f = fCC6 / 32
  927  1                          // 6: f = fCC6 / 64
  928  1                          // 7: f = fCC6 / 128
  929  1           (0U    <<11U)| // T13PRE Timer T13 Prescaler Bit
  930  1                          // 0: additional prescaler disabled
  931  1                          // 1: additional prescaler enabled
  932  1           (0U    <<12U)| // T13R Timer T13 Run Bit (rh)
  933  1                          // 0: Timer is stopped
  934  1                          // 1: Timer is running
  935  1           (0U    <<13U));// STE13 Timer T13 Shadow Transfer Enable (rh)
  936  1                          // 0: Shadow register transfer is disabled
  937  1                          // 1: Shadow register transfer is enabled
  938  1      
  939  1         // save CCU60_TCTR2
  940  1         Ccu60Tctr2Save = CCU60_TCTR2;
  941  1      
  942  1         // enable T13 single-shot, clear other T13 bits,
  943  1         // leave bits T12SSC and T12RSEL unchanged
  944  1         CCU60_TCTR2 = (CCU60_TCTR2 & ((1U <<0U)|(3U <<8U))) |
  945  1         ((0U    <<0U) | // T12SSC T12 Single Shot Control
  946  1          (1U    <<1U) | // T13SSC T13 Single Shot Control
  947  1          (0U    <<2U) | // T13TEC T13 Trigger Event Control to start T13
  948  1                         // 0: No action
  949  1                         // 1: T13R set on T12 compare event on channel 0
  950  1                         // 2: T13R set on T12 compare event on channel 1
  951  1                         // 3: T13R set on T12 compare event on channel 2
  952  1                         // 4: T13R set on any T12 compare event (ch. 0, 1, 2)
  953  1                         // 5: T13R set on period-match of T12
  954  1                         // 6: T13R set on zero-match of T12 (while counting up)
  955  1                         // 7: Any edge of inputs CCPOSx
  956  1          (0U    <<5U) | // T13TED T13 Trigger Event Direction for T13TEC trigger
  957  1                         // 0: Reserved, no action
  958  1                         // 1: While T12 is counting up
  959  1                         // 2: While T12 is counting down
  960  1                         // 3: Independent on the count direction of T12
  961  1          (0U    <<8U) | // T12RSEL T12 External Run Selection
  962  1                         // 0: External setting of T12R disabled
  963  1                         // 1: T12R set on rising edge of T12HR
  964  1                         // 2: T12R set on falling edge of T12HR
  965  1                         // 3: T12R set on any edge of T12HR
  966  1          (0U    <<10U));// T13RSEL T13 External Run Selection
  967  1                         // 0: External setting of T13R is disabled
  968  1                         // 1: T13R set on rising edge of T13HR
  969  1                         // 2: T13R set on falling edge of T13HR
  970  1                         // 3: T13R set on any edge of T13HR
  971  1      
  972  1         // save CCU60_PISELH
  973  1         Ccu60PiselhSave = CCU60_PISELH;
  974  1      
  975  1         // enable T13HRA input (rising edge), leave T12 bits unchanged
  976  1          CCU60_PISELH = (CCU60_PISELH & (3U <<2U)) |
  977  1          ((0U    <<0U) | // IST13HR T13 Input Select for T13HR
  978  1                          // 0: T13HRA, 1: T13HRB, 2: T13HRC, 3: T13HRD
  979  1           (0U    <<2U) | // ISCNT12 T12 Input Select for Counting Input
  980  1                          // 0: T12 prescaler, 1: TCTR4.CNT12 written with 1,
  981  1                          // 2: Rising edge on T12HR signal, 3: Falling edge on T12HR signal
  982  1           (0U    <<4U)); // ISCNT13 T13 Input Select for Counting Input
  983  1                          // 0: T13 prescaler, 1: TCTR4.CNT13 written with 1,
  984  1                          // 2: Rising edge on T13HR signal, 3: Falling edge on T13HR signal
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 17  

  985  1      
  986  1      } // end of function SCS_InitTimer
  987         
  988         //****************************************************************************;
  989         // @Function      void SCS_RestoreTimer (void)
  990         //-----------------------------------------------------------------------------
  991         // @Description   This expert level function restores the old CCU6 register
  992         //                values.
  993         //
  994         //                Notes:
  995         //                - It is assumed that the CCU6 registers have been saved by
  996         //                  execution of SCS_InitTimer.
  997         //                - The function will stop and clear T13.
  998         //                - The user may call this function after the last SCS driver
  999         //                  function.
 1000         //                - The user is responsible for disabling the register protection.
 1001         //
 1002         //-----------------------------------------------------------------------------
 1003         // @Returnvalue   None
 1004         //
 1005         //-----------------------------------------------------------------------------
 1006         // @Parameters    None
 1007         //
 1008         //-----------------------------------------------------------------------------
 1009         // @Date          2020/1/14
 1010         //
 1011         //-----------------------------------------------------------------------------
 1012         
 1013         // USER CODE BEGIN (SCS_RestoreTimer,1)
 1014         
 1015         // USER CODE END
 1016         
 1017         void SCS_RestoreTimer(void)
 1018         {
 1019  1         // stop T13, clear T13
 1020  1         CCU60_TCTR4 =
 1021  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
 1022  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
 1023  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
 1024  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w)
 1025  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
 1026  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
 1027  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
 1028  1           (1U    <<8U) | // T13RR Timer 13 Run Reset (w)
 1029  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
 1030  1           (1U    <<10U)| // T13RES Timer 13 Reset (w)
 1031  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
 1032  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
 1033  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
 1034  1      
 1035  1        // restore CCU60_MCFG
 1036  1        CCU60_MCFG = Ccu60McfgSave;
 1037  1      
 1038  1        // restore CCU60_TCTR0
 1039  1        CCU60_TCTR0 = Ccu60Tctr0Save;
 1040  1      
 1041  1        // restore CCU60_TCTR2
 1042  1        CCU60_TCTR2 = Ccu60Tctr2Save;
 1043  1      
 1044  1        // restore CCU60_PISELH
 1045  1        CCU60_PISELH = Ccu60PiselhSave;
 1046  1      
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 18  

 1047  1        // restore CCU60_KSCFG, enable change
 1048  1        CCU60_KSCFG = Ccu60KscfgSave |
 1049  1          ((0U    <<0U) | // MODEN Module Enable
 1050  1           (1U    <<1U) | // BPMODEN Bit Protection for MODEN, set to 1 for change (w)
 1051  1           (0U    <<4U) | // NOMCFG Normal Operation Mode Configuration
 1052  1                          // kernel mode applied in normal operation mode
 1053  1           (0U    <<7U) | // BPNOM Bit Protection for NOMCFG, set to 1 for change (w)
 1054  1           (0U    <<8U) | // SUMCFG Suspend Mode Configuration
 1055  1                          // Kernel mode applied in suspend mode
 1056  1           (0U    <<11U)| // BPSUM Bit Protection for SUMCFG, set to 1 for change (w)
 1057  1           (0U    <<12U)| // COMCFG Clock Off Mode Configuration
 1058  1                          // kernel mode applied in clock off mode
 1059  1           (0U    <<15U));// BPCOM Bit Protection for COMCFG, set to 1 for change (w)
 1060  1      
 1061  1      } // end of function SCS_RestoreTimer
 1062         
 1063         //****************************************************************************;
 1064         // @Function      SCS_ErrorType SCS_CheckFreqOscHiPrec (void)
 1065         //
 1066         //-----------------------------------------------------------------------------
 1067         // @Description   This expert level function checks the high precision
 1068         //                oscillator for valid output frequency.
 1069         //
 1070         //-----------------------------------------------------------------------------
 1071         // @Returnvalue   Error code
 1072         //
 1073         //-----------------------------------------------------------------------------
 1074         // @Parameters    None
 1075         //
 1076         //-----------------------------------------------------------------------------
 1077         // @Date          2020/1/14
 1078         //
 1079         //-----------------------------------------------------------------------------
 1080         
 1081         // USER CODE BEGIN (SCS_CheckFreqOscHiPrec,1)
 1082         
 1083         // USER CODE END
 1084         
 1085         
 1086         SCS_ErrorType SCS_CheckFreqOscHiPrec(void)
 1087         {
 1088  1         unsigned int Attempts;
 1089  1      
 1090  1         // initialize attempts
 1091  1         Attempts = (unsigned int)SCS_ATTEMPTS_OSC_HP;
 1092  1      
 1093  1         do
 1094  1         {
 1095  2           // start timer
 1096  2           SCS_StartTimer(GET_CYCLES(SCS_TIME_OSC_HP_PLLV, SCS_F_INT_10MHZ));
 1097  2      
 1098  2           // wait until oscillator is usable or time is over
 1099  2           do
 1100  2           {
 1101  3           }
 1102  2           while((!SCU_HPOSCCON_PLLV) && CCU60_TCTR0_T13R);
 1103  2      
 1104  2           if(!SCU_HPOSCCON_PLLV)
 1105  2           {
 1106  3             // timeout error
 1107  3             return SCS_STATE_TO_OSC_HP_PLLV;
 1108  3           }
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 19  

 1109  2      
 1110  2           // clear status bit for high precision osc. frequency below limit
 1111  2           SCU_STATCLR1 =
 1112  2             (0U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1113  2             (0U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1114  2             (1U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1115  2             (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1116  2             (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1117  2             (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1118  2      
 1119  2      
 1120  2           // start timer, timeout for fSYS = 10 MHz
 1121  2           SCS_StartTimer(GET_CYCLES(SCS_TIME_OSC_HP_1024, SCS_F_INT_10MHZ));
 1122  2      
 1123  2           // wait until frequency error occurs, oscillator is stable or time is over
 1124  2           do
 1125  2           {
 1126  3           }
 1127  2           while((!SCU_HPOSCCON_OSC2L1) && (!SCU_PLLSTAT_OSCLOCK) && CCU60_TCTR0_T13R);
 1128  2           if(!SCU_HPOSCCON_OSC2L1 && SCU_PLLSTAT_OSCLOCK)
 1129  2           {
 1130  3             // no frequency error, oscillator is stable
 1131  3             return SCS_STATE_NO_ERROR;
 1132  3           }
 1133  2           // decrement attempts
 1134  2           Attempts--;
 1135  2         }
 1136  1         while(Attempts != 0U);
 1137  1      
 1138  1         // error: too many attempts
 1139  1         return SCS_STATE_OFW_ATTEMPTS_OSC_HP;
 1140  1      
 1141  1      }  // end of function SCS_CheckFreqOscHiPrec
 1142         
 1143         //****************************************************************************;
 1144         // @Function      SCS_ErrorType SCS_ApplyNewPDiv (unsigned int PDiv)
 1145         //
 1146         //-----------------------------------------------------------------------------
 1147         // @Description   This expert level function applies a new P divider value to
 1148         //                the PLL frequency.
 1149         //                Notes:
 1150         //                - If the divider is already set to the specified value, the
 1151         //                  function will return immediately without error.
 1152         //                - The user is responsible for disabling the register protection.
 1153         //
 1154         //-----------------------------------------------------------------------------
 1155         // @Returnvalue   Error code
 1156         //
 1157         //-----------------------------------------------------------------------------
 1158         // @Parameters    PDiv: P divider value
 1159         //
 1160         //-----------------------------------------------------------------------------
 1161         // @Date          2020/1/14
 1162         //
 1163         //-----------------------------------------------------------------------------
 1164         
 1165         // USER CODE BEGIN (SCS_ApplyNewPDiv,1)
 1166         
 1167         // USER CODE END
 1168         
 1169         
 1170         SCS_ErrorType SCS_ApplyNewPDiv(unsigned int PDiv)
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 20  

 1171         {
 1172  1         if(PDiv == SCU_PLLCON1_PDIV)
 1173  1         {
 1174  2           // new value = old value: do nothing, return without error
 1175  2           return SCS_STATE_NO_ERROR;
 1176  2         }
 1177  1      
 1178  1         // clear status bit for high precision osc. frequency below limit
 1179  1         SCU_STATCLR1 =
 1180  1           (1U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1181  1           (1U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1182  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1183  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1184  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1185  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1186  1      
 1187  1         // set P divider value. clear P acknowledge
 1188  1         // leave bits PLLPWD, OSCSEL, AOSCSEL, EMCLKEN, EMFINDISEN unchanged
 1189  1         SCU_PLLCON1 = 
 1190  1           (SCU_PLLCON1 & ((1U <<0U)|(1U <<1U)|(1U <<3U)|(1U <<5U)|(1U <<6U))) | 
 1191  1          ((0U    <<0U) | // PLLPWD PLL Power Saving Mode
 1192  1                          // 0: Normal behavior
 1193  1                          // 1: PLL block is put into power saving mode
 1194  1           (0U    <<1U) | // OSCSEL Oscillator Input Selection
 1195  1                          // 0: PLL external oscillator
 1196  1                          // 1: PLL internal oscillator
 1197  1           (0U    <<2U) | // RESLD Restart VCO Lock Detection (w)
 1198  1                          // Resets PLLSTAT.VCOLOCK and restarts VCO lock detection
 1199  1           (0U    <<3U) | // AOSCSEL Asynchronous Oscillator Input Selection
 1200  1                          // 0: Configuration is controlled via bit OSCSEL
 1201  1                          // 1: PLL internal clock is selected asynchronously
 1202  1           (0U    <<5U) | // EMCLKEN VCOLCK Emergency System Clock Source Select Enable
 1203  1                          // 0: MCM controlled by SYSCON0.CLKSEL in VCOLCK emergency case
 1204  1                          // 1: MCM controlled by SYSCON0.EMCLKSEL in VCOLCK emergency case
 1205  1           (0U    <<6U) | // EMFINDISEN Emergency Input Clock Disconnect Enable
 1206  1                          // 0: PLLSTAT.FINDIS not updated in VCOLCK emergency case
 1207  1                          // 1: PLLSTAT.FINDIS is set in VCOLCK emergency case
 1208  1           (PDiv  <<8U) | // PDIV P-Divider Value
 1209  1                          // 0..15: P-Divider = PDIV + 1
 1210  1           (0U    <<15U));// PACK P-Divider Ready Acknowledge
 1211  1                          // Provides acknowledge to PRDY
 1212  1      
 1213  1         // wait until P acknowledge = 0 with timeout
 1214  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_PRDY))
 1215  1         {
 1216  2           return SCS_STATE_TO_PDIV;
 1217  2         }
 1218  1      
 1219  1         // set P acknowledge
 1220  1         // SCU_PLLCON1_PACK = 1U; ; not available depending on SFR file
 1221  1         SCU_PLLCON1 |= (1U <<15U);
 1222  1      
 1223  1         // wait until P acknowledge = 1 with timeout
 1224  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_PRDY))
 1225  1         {
 1226  2           return SCS_STATE_TO_PDIV;
 1227  2         }
 1228  1      
 1229  1         // no error
 1230  1         return SCS_STATE_NO_ERROR;
 1231  1      
 1232  1      }  // end of function SCS_ApplyNewPDiv
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 21  

 1233         
 1234         //****************************************************************************;
 1235         // @Function      SCS_ErrorType SCS_ApplyNewNDiv (unsigned int NDiv)
 1236         //
 1237         //-----------------------------------------------------------------------------
 1238         // @Description   This expert level function applies a new N divider value to
 1239         //                the PLL frequency.
 1240         //                Notes:
 1241         //                - If the divider is already set to the specified value, the
 1242         //                  function will return immediately without error.
 1243         //                - The user is responsible for disabling the register protection.
 1244         //
 1245         //-----------------------------------------------------------------------------
 1246         // @Returnvalue   Error code
 1247         //
 1248         //-----------------------------------------------------------------------------
 1249         // @Parameters    NDiv: N divider value
 1250         //
 1251         //-----------------------------------------------------------------------------
 1252         // @Date          2020/1/14
 1253         //
 1254         //-----------------------------------------------------------------------------
 1255         
 1256         // USER CODE BEGIN (SCS_ApplyNewNDiv,1)
 1257         
 1258         // USER CODE END
 1259         
 1260         
 1261         SCS_ErrorType SCS_ApplyNewNDiv(unsigned int NDiv)
 1262         {
 1263  1         if(NDiv == SCU_PLLCON0_NDIV)
 1264  1         {
 1265  2           // new value = old value: do nothing, return without error
 1266  2           return SCS_STATE_NO_ERROR;
 1267  2         }
 1268  1      
 1269  1         // clear VCO Lock Detection Lost and VCO Lock Detection Reached
 1270  1         SCU_STATCLR1 =
 1271  1           (1U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1272  1           (1U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1273  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1274  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1275  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1276  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1277  1      
 1278  1         // set N divider value. clear N acknowledge
 1279  1         // leave bits VCOBY, VCOPWD, VCOSEL unchanged
 1280  1         SCU_PLLCON0 = (SCU_PLLCON0 & ((1U <<0U)|(1U <<1U)|(1U <<2U))) |
 1281  1          ((0U    <<0U) | // VCOBY Bypass
 1282  1                          // 0: Normal operation, VCO is not bypassed
 1283  1                          // 1: Prescaler Mode; VCO is bypassed
 1284  1           (0U    <<1U) | // VCOPWD VCO Power Saving Mode
 1285  1                          // 0: Normal behavior
 1286  1                          // 1: VCO is put into power saving mode
 1287  1           (0U    <<2U) | // VCOSEL VCO Range Select
 1288  1                          // 0: 48...112 MHz
 1289  1                          // 1: 96...160 MHz
 1290  1           (0U    <<4U) | // REGENCLR PLL Power Regulator Enable Clear (w)
 1291  1                          // 0: Configuration for PLL power regulator  unchanged
 1292  1                          // 1: PLL is not powered (no operation possible)
 1293  1           (0U    <<5U) | // REGENSET PLL Power Regulator Enable Set (w)
 1294  1                          // 0: Configuration for PLL power regulator unchanged
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 22  

 1295  1                          // 1: PLL is powered (operation possible)
 1296  1           (NDiv  <<8U) | // NDIV N-Divider Value
 1297  1                          // 0..63: N-Divider = NDIV + 1
 1298  1           (0U    <<15U));// NACK N-Divider Ready Acknowledge
 1299  1                          // Provides acknowledge to NRDY
 1300  1      
 1301  1         // wait until N acknowledge = 0 with timeout
 1302  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_NRDY))
 1303  1         {
 1304  2           return SCS_STATE_TO_NDIV;
 1305  2         }
 1306  1      
 1307  1         // set N acknowledge
 1308  1         // SCU_PLLCON0_NACK = 1U; not available depending on SFR file
 1309  1         SCU_PLLCON0 |= (1U <<15U);
 1310  1      
 1311  1         // wait until N acknowledge = 1 with timeout
 1312  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_NRDY))
 1313  1         {
 1314  2           return SCS_STATE_TO_NDIV;
 1315  2         }
 1316  1      
 1317  1         // no error
 1318  1         return SCS_STATE_NO_ERROR;
 1319  1      
 1320  1      }  // end of function SCS_ApplyNewNDiv
 1321         
 1322         //****************************************************************************;
 1323         // @Function      SCS_ErrorType SCS_ApplyNewK1Div (unsigned int K1Div)
 1324         //
 1325         //-----------------------------------------------------------------------------
 1326         // @Description   This expert level function applies a new K1 divider value to
 1327         //                the PLL frequency.
 1328         //                Notes:
 1329         //                - If the divider is already set to the specified value, the
 1330         //                  function will return immediately without error.
 1331         //                - The user is responsible for disabling the register protection.
 1332         //
 1333         //-----------------------------------------------------------------------------
 1334         // @Returnvalue   Error code
 1335         //
 1336         //-----------------------------------------------------------------------------
 1337         // @Parameters    K1Div: K1 divider value
 1338         //
 1339         //-----------------------------------------------------------------------------
 1340         // @Date          2020/1/14
 1341         //
 1342         //-----------------------------------------------------------------------------
 1343         
 1344         // USER CODE BEGIN (SCS_ApplyNewK1Div,1)
 1345         
 1346         // USER CODE END
 1347         
 1348         
 1349         SCS_ErrorType SCS_ApplyNewK1Div(unsigned int K1Div)
 1350         {
 1351  1         if(K1Div == SCU_PLLCON2_K1DIV)
 1352  1         {
 1353  2           // new value = old value: do nothing, return without error
 1354  2           return SCS_STATE_NO_ERROR;
 1355  2         }
 1356  1      
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 23  

 1357  1         // set K1 divider value, clear K1 acknowledge 
 1358  1         SCU_PLLCON2 = 
 1359  1           (K1Div <<0U) | // K1DIV K1-Divider Value
 1360  1                          // 0..511: K1-Divider = K1DIV + 1
 1361  1           (0U    <<15U); // K1ACK K1-Divider Ready Acknowledge
 1362  1                          // Provides acknowledge to K1RDY
 1363  1      
 1364  1         // wait until K1 acknowledge = 0 with timeout
 1365  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_K1RDY))
 1366  1         {
 1367  2           return SCS_STATE_TO_K1DIV;
 1368  2         }
 1369  1      
 1370  1         // set K1 acknowledge
 1371  1         SCU_PLLCON2_K1ACK = 1U;
 1372  1      
 1373  1         // wait until K1 acknowledge = 1 with timeout
 1374  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_K1RDY))
 1375  1         {
 1376  2           return SCS_STATE_TO_K1DIV;
 1377  2         }
 1378  1      
 1379  1         // no error
 1380  1         return SCS_STATE_NO_ERROR;
 1381  1      
 1382  1      }  // end of function SCS_ApplyNewK1Div
 1383         
 1384         //****************************************************************************;
 1385         // @Function      SCS_ErrorType SCS_ApplyNewK2Div (unsigned int K2Div)
 1386         //
 1387         //-----------------------------------------------------------------------------
 1388         // @Description   This expert level function applies a new K2 divider value to
 1389         //                the PLL frequency.
 1390         //                Notes:
 1391         //                - If the divider is already set to the specified value, the
 1392         //                  function will return immediately without error.
 1393         //                - The user is responsible for disabling the register protection.
 1394         //
 1395         //-----------------------------------------------------------------------------
 1396         // @Returnvalue   Error code
 1397         //
 1398         //-----------------------------------------------------------------------------
 1399         // @Parameters    K2Div: K2 divider value
 1400         //
 1401         //-----------------------------------------------------------------------------
 1402         // @Date          2020/1/14
 1403         //
 1404         //-----------------------------------------------------------------------------
 1405         
 1406         // USER CODE BEGIN (SCS_ApplyNewK2Div,1)
 1407         
 1408         // USER CODE END
 1409         
 1410         
 1411         SCS_ErrorType SCS_ApplyNewK2Div(unsigned int K2Div)
 1412         {
 1413  1         if(K2Div == SCU_PLLCON3_K2DIV)
 1414  1         {
 1415  2           // new value = old value: do nothing, return without error
 1416  2           return SCS_STATE_NO_ERROR;
 1417  2         }
 1418  1      
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 24  

 1419  1         // set K2 divider value, clear K2 acknowledge 
 1420  1         SCU_PLLCON3 = 
 1421  1           (K2Div <<0U) | // K2DIV K2-Divider Value
 1422  1                          // 0..511: K2-Divider = K2DIV + 1
 1423  1           (0U    <<15U); // K2ACK K2-Divider Ready Acknowledge
 1424  1                          // Provides acknowledge to K2RDY
 1425  1      
 1426  1         // wait until K2 acknowledge = 0 with timeout
 1427  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_K2RDY))
 1428  1         {
 1429  2           return SCS_STATE_TO_K2DIV;
 1430  2         }
 1431  1      
 1432  1         // set K2 acknowledge
 1433  1         // SCU_PLLCON3_K2ACK = 1U; not available depending on SFR file
 1434  1         SCU_PLLCON3 |= (1U <<15U);
 1435  1      
 1436  1         // wait until K2 acknowledge = 1 with timeout
 1437  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_K2RDY))
 1438  1         {
 1439  2           return SCS_STATE_TO_K2DIV;
 1440  2         }
 1441  1      
 1442  1         // no error
 1443  1         return SCS_STATE_NO_ERROR;
 1444  1      
 1445  1      }  // end of function SCS_ApplyNewK2Div
 1446         
 1447         //****************************************************************************;
 1448         // @Function      SCS_ErrorType SCS_SelectVcoSrcOscHiPrec (void)
 1449         //
 1450         //-----------------------------------------------------------------------------
 1451         // @Description   This expert level function selects the high precision 
 1452         //                oscillator as the source for the VCO.
 1453         //                Notes:
 1454         //                - The user is responsible for disabling the register protection.
 1455         //
 1456         //-----------------------------------------------------------------------------
 1457         // @Returnvalue   Error code
 1458         //
 1459         //-----------------------------------------------------------------------------
 1460         // @Parameters    None
 1461         //
 1462         //-----------------------------------------------------------------------------
 1463         // @Date          2020/1/14
 1464         //
 1465         //-----------------------------------------------------------------------------
 1466         
 1467         // USER CODE BEGIN (SCS_SelectVcoSrcOscHiPrec,1)
 1468         
 1469         // USER CODE END
 1470         
 1471         
 1472         SCS_ErrorType SCS_SelectVcoSrcOscHiPrec(void)
 1473         
 1474         {
 1475  1         // clear OSCSEL. clear AOSCSEL, leave other bits unchanged
 1476  1         SCU_PLLCON1 &=
 1477  1           (1U    <<0U) | // PLLPWD PLL Power Saving Mode
 1478  1                          // 0: Normal behavior
 1479  1                          // 1: PLL block is put into power saving mode
 1480  1           (0U    <<1U) | // OSCSEL Oscillator Input Selection
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 25  

 1481  1                          // 0: PLL external oscillator
 1482  1                          // 1: PLL internal oscillator
 1483  1           (1U    <<2U) | // RESLD Restart VCO Lock Detection (w)
 1484  1                          // Resets PLLSTAT.VCOLOCK and restarts VCO lock detection
 1485  1           (0U    <<3U) | // AOSCSEL Asynchronous Oscillator Input Selection
 1486  1                          // 0: Configuration is controlled via bit OSCSEL
 1487  1                          // 1: PLL internal clock is selected asynchronously
 1488  1           (1U    <<5U) | // EMCLKEN VCOLCK Emergency System Clock Source Select Enable
 1489  1                          // 0: MCM controlled by SYSCON0.CLKSEL in VCOLCK emergency case
 1490  1                          // 1: MCM controlled by SYSCON0.EMCLKSEL in VCOLCK emergency case
 1491  1           (1U    <<6U) | // EMFINDISEN Emergency Input Clock Disconnect Enable
 1492  1                          // 0: PLLSTAT.FINDIS not updated in VCOLCK emergency case
 1493  1                          // 1: PLLSTAT.FINDIS is set in VCOLCK emergency case
 1494  1           (0xFU  <<8U) | // PDIV P-Divider Value
 1495  1                          // 0..15: P-Divider = PDIV + 1
 1496  1           (1U    <<15U); // PACK P-Divider Ready Acknowledge
 1497  1                          // Provides acknowledge to PRDY
 1498  1      
 1499  1         // wait until high precision oscillator is selected (OSCSELST = 0), with timeout
 1500  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_OSCSELST))
 1501  1         {
 1502  2           return SCS_STATE_TO_OSC_HP_SEL;
 1503  2         }
 1504  1      
 1505  1         // no error
 1506  1         return SCS_STATE_NO_ERROR;
 1507  1      
 1508  1      }  // end of function SCS_SelectVcoSrcOscHiPrec
 1509         
 1510         //****************************************************************************;
 1511         // @Function      SCS_ErrorType SCS_EnableVcoLockEmerg (void)
 1512         //
 1513         //-----------------------------------------------------------------------------
 1514         // @Description   This expert level function enables the VCO loss-of-lock
 1515         //                emergency handling.
 1516         //
 1517         //-----------------------------------------------------------------------------
 1518         // @Returnvalue   Error code
 1519         //
 1520         //-----------------------------------------------------------------------------
 1521         // @Parameters    None
 1522         //
 1523         //-----------------------------------------------------------------------------
 1524         // @Date          2020/1/14
 1525         //
 1526         //-----------------------------------------------------------------------------
 1527         
 1528         // USER CODE BEGIN (SCS_EnableVcoLockEmerg,1)
 1529         
 1530         // USER CODE END
 1531         
 1532         
 1533         SCS_ErrorType SCS_EnableVcoLockEmerg(void)
 1534         
 1535         {
 1536  1         unsigned int Work;
 1537  1      
 1538  1         if(!SCU_PLLSTAT_VCOLOCK)
 1539  1         {
 1540  2           // VCO unlocked
 1541  2           return SCS_STATE_VCO_UNLOCKED;
 1542  2         }
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 26  

 1543  1      
 1544  1         // clear VCO Lock Detection Lost and VCO Lock Detection Reached
 1545  1         SCU_STATCLR1 =
 1546  1           (1U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1547  1           (1U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1548  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1549  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1550  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1551  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1552  1      
 1553  1        // disable emergency clock selection
 1554  1        SCU_PLLCON1_EMCLKEN = 0U;
 1555  1      
 1556  1        // disable emergency clock selection
 1557  1        SCU_SYSCON0_EMCLKSELEN = 0U;
 1558  1      
 1559  1         // clear loss-of-lock emergency state
 1560  1         SCU_STATCLR0 =
 1561  1           (0U    <<12U) | // Clear bit SYSCON0.EMSOSC (w)
 1562  1           (1U    <<13U) ; // Clear bit SYSCON0.EMSVCO (w)
 1563  1      
 1564  1        // enable emergency input clock disconnection
 1565  1        SCU_PLLCON1_EMFINDISEN = 1U;
 1566  1      
 1567  1        // clear VCOLCK Trap Request Flag
 1568  1        SCU_TRAPCLR =
 1569  1          (0U    <<0U) | // FAT Clear Flash Access Trap Request
 1570  1          (0U    <<1U) | // ESR0T Clear ESR0 Trap Request
 1571  1          (0U    <<2U) | // ESR1T Clear ESR1 Trap Request
 1572  1          (0U    <<3U) | // ESR2T Clear ESR2 Trap Request
 1573  1          (0U    <<4U) | // OSCWDTT Clear OSCWDT Trap Request
 1574  1          (0U    <<5U) | // RAT Clear Register Access Trap Request
 1575  1          (0U    <<6U) | // PET Clear Register Parity Error Trap Request
 1576  1          (1U    <<7U) ; // VCOLCKT Clear VCOLCK Trap Request
 1577  1      
 1578  1        // enable VCOLCK trap request
 1579  1        SCU_TRAPDIS &=
 1580  1         ((1U    <<0U) | // FAT Disable Flash Access Trap Request
 1581  1          (1U    <<1U) | // ESR0T Disable ESR0 Trap Request
 1582  1          (1U    <<2U) | // ESR1T Disable ESR1 Trap Request
 1583  1          (1U    <<3U) | // ESR2T Disable ESR2 Trap Request
 1584  1          (1U    <<4U) | // OSCWDTT Disable OSCWDT Trap Request
 1585  1          (1U    <<5U) | // RAT Disable Register Access Trap Request
 1586  1          (1U    <<6U) | // PET Disable Register Parity Error Trap Request
 1587  1          (0U    <<7U)); // VCOLCKT Disable VCOLCK Trap Request
 1588  1      
 1589  1        Work = SCU_PLLSTAT;
 1590  1      
 1591  1        if((Work &
 1592  1         ((0U    <<0U) | // VCOBYST VCO Bypass Status Freerunning/Normal (rh)
 1593  1          (0U    <<1U) | // PWDSTAT Power-saving Mode Status (rh)
 1594  1          (0U    <<2U) | // OSCSELST Oscillator Input Selection Status OSC_PLL (rh)
 1595  1          (0U    <<3U) | // VCOLOCK PLL VCO Lock Status (rh)
 1596  1          (0U    <<4U) | // BY Bypass Mode Status (rh)
 1597  1          (0U    <<5U) | // PRDY P-Divider Ready Status (rh)
 1598  1          (0U    <<6U) | // NRDY N-Divider Ready Status (rh)
 1599  1          (0U    <<7U) | // K1RDY K1-Divider Ready Status (rh)
 1600  1          (0U    <<8U) | // K2RDY K1-Divider Ready Status (rh)
 1601  1          (0U    <<9U) | // FINDIS Input Clock Disconnect Select Status (rh)
 1602  1          (1U    <<10U)| // VCOL0 VCO Lock Detection Lost Status (rh)
 1603  1          (1U    <<11U)| // VCOL1 VCO Lock Detection Reached Status (rh)
 1604  1          (0U    <<12U)))// REGSTAT PLL Power Regulator Status powered (operation possible) (rh)
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 27  

 1605  1          || (!(Work &
 1606  1          (1U    <<3U))))// VCOLOCK PLL VCO Lock Status (rh)
 1607  1      
 1608  1          {
 1609  2            // VCOL0 = 1 or VCOL1 = 1 or VCOLOCK = 0: VCO unlocked
 1610  2            return SCS_STATE_VCO_UNLOCKED;
 1611  2          }
 1612  1      
 1613  1         // no error
 1614  1         return SCS_STATE_NO_ERROR;
 1615  1      
 1616  1      }  // end of function SCS_EnableVcoLockEmerg
 1617         
 1618         //****************************************************************************;
 1619         // @Function      SCS_ErrorType SCS_DisableVcoBypass (void)
 1620         //
 1621         //-----------------------------------------------------------------------------
 1622         // @Description   This expert level function disables VCO bypass.
 1623         //                Notes:
 1624         //                - The user is responsible for disabling the register protection.
 1625         //
 1626         //-----------------------------------------------------------------------------
 1627         // @Returnvalue   Error code
 1628         //
 1629         //-----------------------------------------------------------------------------
 1630         // @Parameters    None
 1631         //
 1632         //-----------------------------------------------------------------------------
 1633         // @Date          2020/1/14
 1634         //
 1635         //-----------------------------------------------------------------------------
 1636         
 1637         // USER CODE BEGIN (SCS_DisableVcoBypass,1)
 1638         
 1639         // USER CODE END
 1640         
 1641         
 1642         SCS_ErrorType SCS_DisableVcoBypass(void)
 1643         
 1644         {
 1645  1         // disable VCO bypass
 1646  1         SCU_PLLCON0_VCOBY = 0U;
 1647  1      
 1648  1         // wait until VCO bypass status = 1 with timeout
 1649  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_VCOBYST))
 1650  1         {
 1651  2           return SCS_STATE_TO_VCOBYST;
 1652  2         }
 1653  1      
 1654  1      
 1655  1         // no error
 1656  1         return SCS_STATE_NO_ERROR;
 1657  1      
 1658  1      }  // end of function SCS_DisableVcoBypass
 1659         
 1660         //****************************************************************************;
 1661         // @Function      SCS_ErrorType SCS_EnableVcoBypass (void)
 1662         //
 1663         //-----------------------------------------------------------------------------
 1664         // @Description   This expert level function enables VCO bypass.
 1665         //                Notes:
 1666         //                - The user is responsible for disabling the register protection.
C166 COMPILER V7.00, SCS                                                                   04/01/2020 13:45:19 PAGE 28  

 1667         //
 1668         //-----------------------------------------------------------------------------
 1669         // @Returnvalue   Error code
 1670         //
 1671         //-----------------------------------------------------------------------------
 1672         // @Parameters    None
 1673         //
 1674         //-----------------------------------------------------------------------------
 1675         // @Date          2020/1/14
 1676         //
 1677         //-----------------------------------------------------------------------------
 1678         
 1679         // USER CODE BEGIN (SCS_EnableVcoBypass,1)
 1680         
 1681         // USER CODE END
 1682         
 1683         
 1684         SCS_ErrorType SCS_EnableVcoBypass(void)
 1685         
 1686         {
 1687  1         // enable VCO bypass
 1688  1         SCU_PLLCON0_VCOBY = 1U;
 1689  1      
 1690  1         // wait until VCO bypass status = 0 with timeout
 1691  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_VCOBYST))
 1692  1         {
 1693  2           return SCS_STATE_TO_VCOBYST;
 1694  2         }
 1695  1      
 1696  1      
 1697  1         // no error
 1698  1         return SCS_STATE_NO_ERROR;
 1699  1      
 1700  1      }  // end of function SCS_EnableVcoBypass


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        1362     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          10     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
