C166 COMPILER V7.00, VEHICLE_CONTROL                                                       04/01/2020 13:45:21 PAGE 1   


C166 COMPILER V7.00, COMPILATION OF MODULE VEHICLE_CONTROL
OBJECT MODULE PLACED IN vehicle_control.obj
COMPILER INVOKED BY: H:\KEILC166\C166\BIN\C166.EXE source\vehicle_control.c MODV2 BROWSE INCDIR(.\source;.\lib) MODV2 DE
                    -BUG PRINT(.\vehicle_control.lst) OBJECT(vehicle_control.obj) 

 stmt lvl     source

    1         /************************************************************
    2         function:Vehicle control rules
    3         date:2019.09.23
    4         last trange: 2019.10.17
    5         author:dowson_tseng
    6         email:dowson.tseng@gmail.com
    7         readme:
    8         *************************************************************/
    9         
   10         #include "MAIN.h"
   11         #include "vehicle_control.h"
   12         #include "steering.h"
   13         #include "speed_control.h"
   14         #include "remote.h"
   15         #include "pid_controler.h"
   16         #include "breaking_control.h"
   17         #include "differential_control.h"
   18         
   19         
   20         extern ubyte ST[8]; 
   21         extern struct remote_receive remote_re; 
   22         struct error_code vehicle_ec;
   23         struct vehicle vehicle_rcv;
   24         struct self_driving auto_cmd;
   25          
   26         struct pid_struct pid;
   27         struct pid_struct pidlf;
   28         struct pid_struct pidlb;
   29         struct pid_struct pidrf;
   30         struct pid_struct pidrb;
   31         
   32         int send_cmd_enable=-1;
   33         int hand_break_mark=0,time_hand_break=0,time_auto_hand_break=0; // ÷…≤±Í÷æŒª∫Õ ÷…≤º∆ ±
   34         int breaking_size_record,torque_size_record,autohold_mark=0;
   35         
   36         
   37         int vehicle_init(void)
   38         {
   39  1              ubyte i=0;
   40  1              //init error code 
   41  1              vehicle_ec.ess_status=0; //emergency stop switch
   42  1              vehicle_ec.lfw_status=0;
   43  1              vehicle_ec.lbw_status=0;
   44  1              vehicle_ec.rfw_status=0;
   45  1              vehicle_ec.rbw_status=0;
   46  1              vehicle_ec.fs_status=0;
   47  1              vehicle_ec.bs_status=0;
   48  1              vehicle_ec.break_status=0;
   49  1              vehicle_ec.bp_status=0;  //battery power
   50  1              vehicle_ec.bms_status=0;
   51  1              vehicle_ec.mode_s_error=0;
   52  1              vehicle_ec.gear_s_error=0;
   53  1              vehicle_ec.remote_error=0;
   54  1              for(i=0;i<8;i++)
C166 COMPILER V7.00, VEHICLE_CONTROL                                                       04/01/2020 13:45:21 PAGE 2   

   55  1                      vehicle_ec.msg_data[i]=0;
   56  1      
   57  1              auto_cmd.steering = 0;  
   58  1      
   59  1              //wait some time to wait anthore mode init ok 
   60  1              delay(1000); //1S
   61  1              //get msg frome remote ,determine which mode you are in.
   62  1              return 0;
   63  1      }
   64         
   65         int vehicle_control(void)
   66         {       //int temp_steering;
   67  1              int conversion_steering=0,auto_conversion_steering=0,conversion_throttle=0;
   68  1              //system init
   69  1              //≥µ¡æ◊¥Ã¨ºÏ≤È
   70  1              //debug 
   71  1                ST[1]=0;
   72  1              send_cmd_enable = 0;
   73  1              vehicle_ec.ess_status=0;
   74  1              //º±Õ£∞¥≈•¥•∑¢£¨“£øÿ∆˜–≈∫≈∂™ ß£¨Ω˚÷π∑¢ÀÕ–≈∫≈
   75  1              if(ST[1]==TRUE||remote_re.t_em_stop==TRUE||remote_re.key==TRUE) 
   76  1              {
   77  2                      vehicle_ec.ess_status=1;
   78  2                      send_cmd_enable = -1;
   79  2                      //ƒ£ Ω∏ƒ±‰Œ™Ω˚÷πøÿ÷∆ƒ£ Ω£¨Õ¨ ±…≤≥µ÷∆∂Ø
   80  2                      return -1;
   81  2              // ÷…≤Œ¥À…£¨≤’√≈Œ¥πÿ£¨Ω˚÷π∑¢ÀÕÀŸ∂»–≈œ¢
   82  2              }else if(remote_re.hand_break==TRUE){ //¥À¥¶÷˜“™”√”⁄±£ª§‘⁄Œﬁ“‚ªÚ≤ª÷™µ¿◊‘∂Øº› ªƒ£ Ω“—∆Ù∂Ø«Èøˆœ¬ø™∆Ù◊‘∂Øº› 
             -ªµº÷¬ ¬π Œ Ã‚
   83  2                      vehicle_ec.ess_status=1;                                                          //À˘“‘√ø¥Œ‘⁄◊‘∂Øº› ª ±º±Õ£Ω‚≥˝÷Æ∫Û–Ë“™÷ÿ–¬∆Ù∂Ø◊‘∂Øº› ªƒ£ Ω∑Ò‘Ú ß–ß
   84  2                      send_cmd_enable = -1;
   85  2      
   86  2                      //µ∆π‚…¡À∏Ã· æ
   87  2                      if(remote_re.t_steering_vle>1||remote_re.t_throttle_vle>1||auto_cmd.steering>1||auto_cmd.speed>1)//”–∂Ø◊
             -˜ ±æÕª·…¡µ∆Ã· æ£¨◊§≥µŒ¥∑≈      
   88  2                              {P7_OUT_P3 = 0;P1_OUT_P0 =0;}
   89  2                      else {P7_OUT_P3 = 1;P1_OUT_P0 =1;}
   90  2                      //Ω˚÷π∑¢ÀÕÀŸ∂»–≈œ¢
   91  2                      //auto_cmd.speed=0;
   92  2                      //remote_re.t_throttle_vle=0;
   93  2                      return -1;
   94  2              }else {send_cmd_enable = 0;vehicle_ec.ess_status=0;}
   95  1      
   96  1              if(remote_re.t_way_trl==0)      //≈–∂œøÿ÷∆ƒ£ Ω,“£øÿ∆˜ƒ£ Ω
   97  1              {
   98  2                      //≈–∂œ «∑ÒŒ™≤ÓÀŸƒ£ Ω
   99  2                      if(remote_re.t_backup3 == 2){  //’˝≥£ƒ£ Ω
  100  3                              //◊™œÚªªÀ„£¨+-1000 to 0-240
  101  3                              send_steering((int)(remote_re.t_steering_vle)*0.12,remote_re.t_steering_mod,0x1 );
  102  3              
  103  3                              //◊™æÿ÷µ◊™ªª
  104  3                              conversion_throttle = (int)(remote_re.t_throttle_vle*0.42);     
  105  3              
  106  3                              if(remote_re.t_breaking_vle>10)   //»Áπ˚”–÷µ£¨Àµ√˜ «ºıÀŸ£¨“ÚŒ™º”ÀŸ∫Õ…≤≥µπ≤”√“ª∏ˆ ˝÷µ
  107  3                                      send_break(remote_re.t_breaking_vle,0x10);        //break max size is 0x1000 
  108  3                                      //send_servo_break(remote_re.t_breaking_vle,0x10);  
  109  3                              else {
  110  4                                      //send_break(BREAKING_FREE,0x10);
  111  4                                      send_servo_break(SERVO_FREE_TORQUE,0x10);
  112  4                                      send_speed((sword)get_vehicle2whell_speed((uword)((float)conversion_throttle*0.1)),remote_re.t_gear,re
             -mote_re.low_speed_mod);        //max well speed :0x0241
  113  4                              }                                       
C166 COMPILER V7.00, VEHICLE_CONTROL                                                       04/01/2020 13:45:21 PAGE 3   

  114  3                      }else {  //≤ÓÀŸƒ£ Ω
  115  3                              //◊™œÚªªÀ„£¨+-1000 to 0-240
  116  3                              remote_re.t_steering_vle+= 1220; //+-1000 to 0-2000,∞—‘≠±æ”¶∏√ «+1024   µ´ «¥Ê‘⁄“ª∂®ª˙–µ…œµƒŒÛ≤ÓŒ™¡À√÷≤
             -π∂¯Œ™1220
  117  3                              conversion_steering = (int)((float)remote_re.t_steering_vle * 0.12)-146;
  118  3                              send_steering(conversion_steering,remote_re.t_steering_mod,0x1 );       
  119  3      
  120  3                              conversion_throttle = (int)(remote_re.t_throttle_vle*0.42);     
  121  3                              if(remote_re.t_breaking_vle>10)   //»Áπ˚”–÷µ£¨Àµ√˜ «ºıÀŸ£¨“ÚŒ™º”ÀŸ∫Õ…≤≥µπ≤”√“ª∏ˆ ˝÷µ
  122  3                                      send_break(remote_re.t_breaking_vle,0x10);        //break max size is 0x1000 
  123  3                                      //send_servo_break(remote_re.t_breaking_vle,0x10);  
  124  3                              else {
  125  4                                      send_break(BREAKING_FREE,0x10);
  126  4                                      //send_servo_break(SERVO_FREE_TORQUE,0x10);
  127  4                                      //send_speed((sword)get_vehicle2whell_speed((uword)((float)conversion_throttle*0.1)),remote_re.t_gear,
             -remote_re.low_speed_mod);      //max well speed :0x0241
  128  4                                      differential_control((sword)get_vehicle2whell_speed((uword)((float)conversion_throttle*0.1)),1,remote_
             -re.t_backup3,remote_re.t_gear);       
  129  4                                      }                                                               
  130  3                      }       
  131  2              }else if(remote_re.t_way_trl==1){  //ªÒ»°◊‘∂Øº› ª ˝æ›≤¢∑¢ÀÕ
  132  2                      
  133  2                      //◊™œÚ÷µªªÀ„£¨◊™œÚª˙◊Ó¥Û‘ –Ì-146 to 146°„ µƒΩ«∂»
  134  2                  auto_conversion_steering =(int)((float)(auto_cmd.steering+1220) * 0.12)-146;                
  135  2                      if(auto_cmd.breaking>10)   //»Áπ˚”–÷µ£¨Àµ√˜ «ºıÀŸ£¨“ÚŒ™…≤≥µ÷µ”≈œ»”⁄ÀŸ∂»÷µ
  136  2                              send_break(auto_cmd.breaking,0x10);       //break max size is 0x1000 
  137  2                      else {
  138  3                              send_break(BREAKING_FREE,0x10);
  139  3                              send_speed((sword)get_vehicle2whell_speed((uword)((float)auto_cmd.speed)),auto_cmd.gear,auto_cmd.low_sp
             -eed_mod);         //max well speed :0x0241
  140  3                      }
  141  2                      send_steering(auto_conversion_steering,auto_cmd.steering_mod,0x1);
  142  2                      
  143  2              }
  144  1       
  145  1              return 0;
  146  1      }
  147         
  148         
  149         
  150         
  151         void send_break(uword breaking,ubyte enable)   //”––ß÷µffc0 to 4096
  152         {
  153  1              int i=0;
  154  1              int excursion = 0;
  155  1              ubyte Data[8];
  156  1              breaking_size_record=breaking;
  157  1              for(i=0;i<=7;i++)
  158  1                      Data[i]=0; //clear
  159  1              if (breaking > BREAKING_MAX && breaking < 0xff00)        //BREAKING_MAX
  160  1                      breaking = BREAKING_FREE;//(~(breaking)+1);   remote sizt : real break size
  161  1              //ø™∆Ù÷∆∂Øµ∆
  162  1              if(breaking>100&&breaking<0xff00)
  163  1                      P10_OUT_P11 = 0;
  164  1              else P10_OUT_P11 = 1;
  165  1              excursion =breaking*4;
  166  1              Data[0] = excursion&0xff;
*** WARNING C192 IN LINE 166 OF SOURCE\VEHICLE_CONTROL.C: '=': value truncated
  167  1              Data[1] = excursion>>8;
*** WARNING C192 IN LINE 167 OF SOURCE\VEHICLE_CONTROL.C: '=': value truncated
  168  1              Data[2] = enable;        //enable bit
  169  1              Data[3] = 0x00;
C166 COMPILER V7.00, VEHICLE_CONTROL                                                       04/01/2020 13:45:21 PAGE 4   

  170  1              Data[4] = 0x00;
  171  1              Data[5] = 0x00;
  172  1              Data[6] = 0x00;
  173  1              Data[7] = 0x00;         
  174  1              CAN_vLoadData(BS_430,Data);      //310-340  8-11   
  175  1              CAN_vTransmit(BS_430);  
  176  1              delay(50);              
  177  1      }
  178         
  179         
  180         //calculate the average whell speed
  181         uword average_whell_speed(struct vehicle v_state)
  182         {
  183  1      
  184  1                      
  185  1              //return (v_state.lfw.rpm+v_state.lbw.rpm+v_state.rfw.rpm+v_state.rbw.rpm)/4;
  186  1                      return (v_state.lfw.rpm);
  187  1      }
  188         
  189         ubyte get_whell2vehicle_speed(struct vehicle v_state)  //KM/H
  190         {
  191  1              //Calculate the average wheel speed
  192  1              float vehicle_speed = 0.0,average_wheel_speed=0.0;
  193  1              average_wheel_speed =(v_state.lfw.rpm+v_state.lbw.rpm+v_state.rfw.rpm+v_state.rbw.rpm)/4;
  194  1              vehicle_speed = (average_wheel_speed*3.14*590)/(60*278);
  195  1              return (ubyte)vehicle_speed; 
  196  1      }
  197         
  198         //import vehicle speed transfrom average whell speed
  199         
  200         uword get_vehicle2whell_speed(uword vehicle_speed)  
  201         {
  202  1              float target_whell_speed=0.0;
  203  1              target_whell_speed = ((vehicle_speed*1000.0*60.0)/(3600*0.59*3.14));//(vehicle_speed*60*278)/(3.14*354);
  204  1              return target_whell_speed;
  205  1      }
  206         
  207         
  208         
  209         //vehicle_control
  210         
  211         //pid
  212         
  213         
  214         
  215         float data_pct(int input_size,int max_size)
  216         {
  217  1              float pct;
  218  1              pct = (float)input_size/(float)max_size;
  219  1              return pct;
  220  1      }
  221         
  222         //µÁ◊” ÷…≤øÿ÷∆
  223         // ‰»Î: TRUE£®1£© £∫ πƒ‹  FALSE£®0£©£∫ ßƒ‹
  224         //∑µªÿ÷µ£∫0 øÿ÷∆≥…π¶   -1£∫µÁ◊” ÷…≤¥ÌŒÛ -2£∫µÁ◊” ÷…≤¥¶”⁄π§◊˜◊¥Ã¨
  225         
  226         int autohold (int status)
  227         {
  228  1              if(status == TRUE&&P7_OUT_P4 == 1) //±Ì æµ±«∞ ÷…≤¥¶”⁄ø’œ–◊¥Ã¨
  229  1              {       
  230  2                      if(hand_break_mark == FALSE){
  231  3                              time_hand_break = 0;
C166 COMPILER V7.00, VEHICLE_CONTROL                                                       04/01/2020 13:45:21 PAGE 5   

  232  3                              hand_break_mark = TRUE; //º–ΩÙ◊¥Ã¨                       
  233  3                      }       
  234  2                      if(time_hand_break<15){
  235  3                              P1_OUT_P2 = 0;  //¿≠ ÷…≤µÁª˙Õ®µÁ
  236  3                      }else {P1_OUT_P2 = 1;}           
  237  2                      return 0;
  238  2                      
  239  2              }else if(status == FALSE&&P1_OUT_P2 == 1)
  240  1              {
  241  2                      if(hand_break_mark == TRUE){
  242  3                              time_hand_break = 0;
  243  3                              hand_break_mark = FALSE; //∑≈À…◊¥Ã¨
  244  3                      }
  245  2                      if(time_hand_break<13){
  246  3                              P7_OUT_P4 = 0;  //∑≈ ÷…≤µÁª˙Õ®µÁ
  247  3                      }else {P7_OUT_P4 = 1; SPI_Control();}
  248  2                      
  249  2                      return 0;                       
  250  2              }else if(time_hand_break>15&&P1_OUT_P2==0)
  251  1                      P1_OUT_P2=1;
  252  1              else if(time_hand_break>13&&P7_OUT_P4==0)
  253  1                      P7_OUT_P4=0;
  254  1              if(time_hand_break>15) {
  255  2                      P7_OUT_P4=1;
  256  2                      P1_OUT_P2=1;
  257  2                      }
  258  1              return -2;              
  259  1      }
  260         
  261         //∫Ø ˝π¶ƒ‹√Ë ˆ£∫∏√∫Ø ˝÷ª“™”√◊˜≥§ ±º‰÷∆∂Øµƒ“ª÷¬◊‘∂Ø±£ª§¥Î ©£¨µ±≥§ ±º‰”√÷∆∂ØµÁª˙Ω¯––
  262         //÷∆∂Ø±£≥÷ ±»Á ±º‰π˝≥§ª·‘Ï≥…÷∆∂ØµÁª˙π˝‘ÿø…ƒ‹≥ˆœ÷π ’œ£¨À˘“‘µ± π”√÷∆∂Ø…≤≥µ«“ ±º‰≥¨π˝10S
  263         //÷Æ∫ÛœµÕ≥ª·◊‘∂Ø∆Ù∂Ø ÷…≤£¨Õ¨ ±«ø÷∆ Õ∑≈…≤≥µ°£∏√π¶ƒ‹Ωˆµ±÷∆∂Ø÷µ≤˙…˙«“≥µ…Ìæ≤÷π10S÷Æ∫Û÷˜∂Ø¥•∑¢°£
  264         int auto_autohold(void)
  265         {
  266  1        
  267  1        if(breaking_size_record>0x100&&(vehicle_rcv.lfw.rpm+vehicle_rcv.lbw.rpm+vehicle_rcv.rfw.rpm\
  268  2              +vehicle_rcv.rbw.rpm==0)&&hand_break_mark==FALSE){
  269  2                                              
  270  2                      if(time_auto_hand_break>100) //10S
  271  2                      {
  272  3                              autohold(TRUE);
  273  3                              send_break(BREAKING_FREE,0x10);
  274  3                              autohold_mark=1;
  275  3                      }
  276  2              }else if(torque_size_record>2&&hand_break_mark==TRUE){
  277  2                      autohold(FALSE);
  278  2                      autohold_mark=0;
  279  2              } else time_auto_hand_break=0;
  280  1      
  281  1              return 0;       
  282  1      }
  283         
  284         
  285         
  286         
  287         
  288         
  289         
  290         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
C166 COMPILER V7.00, VEHICLE_CONTROL                                                       04/01/2020 13:45:21 PAGE 6   

  CODE SIZE        =        1284     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =         348     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          30     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
